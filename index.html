<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simpless</title>
    <!-- Include Three.js library -->
    <script src="https://threejs.org/build/three.min.js"></script>
</head>
<body style="margin:0">
    <script>
        // Scene setup
        const scene = new THREE.Scene(); // Create a new scene
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000); // Create a perspective camera
        const renderer = new THREE.WebGLRenderer(); // Create a WebGL renderer
        renderer.setSize(window.innerWidth, window.innerHeight); // Set the size of the renderer
        document.body.appendChild(renderer.domElement); // Append the renderer to the document body

        // Create a central sphere to represent the Sun
        const sunGeometry = new THREE.SphereGeometry(6, 32, 32); // Define the geometry for the sphere
        const sunTexture = new THREE.TextureLoader().load('logo.png'); // Load texture for the sphere
        const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture }); // Create material with the texture
        const sun = new THREE.Mesh(sunGeometry, sunMaterial); // Create a mesh with the geometry and material
        scene.add(sun); // Add the sun to the scene

        // Variables for planets
        const numberOfPlanets = 10; // Number of planets
        const orbitRadiusX = 30; // X radius for the orbit
        const orbitRadiusZ = 15; // Z radius for the orbit
        const orbitTiltAngle = -0.2; // Tilt angle for the orbit
        const orbitingSpheres = []; // Array to store the orbiting spheres (planets)

        // Create planets
        for (let i = 0; i < numberOfPlanets; i++) {
            const planetGeometry = new THREE.SphereGeometry(2, 100, 100); // Define geometry for each planet
            const planetTexture = new THREE.TextureLoader().load(i + '.png'); // Load texture for each planet
            const planetMaterial = new THREE.MeshBasicMaterial({ map: planetTexture }); // Create material with texture
            const planet = new THREE.Mesh(planetGeometry, planetMaterial); // Create a mesh for each planet

            // Position each planet on its orbit
            planet.position.x = orbitRadiusX * Math.cos((2 * Math.PI / numberOfPlanets) * i);
            planet.position.y = orbitRadiusZ * Math.sin((2 * Math.PI / numberOfPlanets) * i) * Math.sin(orbitTiltAngle);
            planet.position.z = orbitRadiusZ * Math.sin((2 * Math.PI / numberOfPlanets) * i) * Math.cos(orbitTiltAngle);

            // Set rotation velocity and damping for each planet
            planet.userData = { 
                rotationVelocity: { x: 0, y: 0 },
                damping: 0.95
            };

            scene.add(planet); // Add each planet to the scene
            orbitingSpheres.push(planet); // Store the planet in the orbitingSpheres array
        }

        // Set camera position and orientation
        camera.position.set(50, 50, -50); // Position the camera
        camera.lookAt(scene.position); // Make the camera look at the center of the scene

        // Raycaster and mouse setup for interaction
        const raycaster = new THREE.Raycaster(); // Create a raycaster for mouse interaction
        const mouse = new THREE.Vector2(); // Vector to store mouse position
        let isDragging = false; // Flag to check if dragging is occurring
        let selectedPlanet = null; // Store the currently selected planet
        let previousMousePosition = { x: 0, y: 0 }; // Store the previous mouse position

        // Update mouse position function
        function updateMousePosition(event) {
            // Normalize mouse position within the canvas
            mouse.x = ((event.clientX || event.touches[0].clientX) / window.innerWidth) * 2 - 1;
            mouse.y = -((event.clientY || event.touches[0].clientY) / window.innerHeight) * 2 + 1;
        }

        // Function to handle mouse down event
        function onMouseDown(event) {
            updateMousePosition(event); // Update the mouse position
            raycaster.setFromCamera(mouse, camera); // Set the raycaster from the camera and mouse position
            const intersects = raycaster.intersectObjects(orbitingSpheres); // Detect intersection with planets

            if (intersects.length > 0) {
                isDragging = true; // Enable dragging
                selectedPlanet = intersects[0].object; // Set the selected planet
                previousMousePosition.x = mouse.x; // Update the previous mouse position
                previousMousePosition.y = mouse.y;
            }
        }

        // Function to handle mouse move event
        function onMouseMove(event) {
            event.preventDefault(); // Prevent default behavior of the event

            if (!isDragging || !selectedPlanet) return; // Exit if not dragging or no planet is selected
            updateMousePosition(event); // Update mouse position

            let deltaX, deltaY;
            if (event.changedTouches) {
                deltaX = event.changedTouches[0].clientX - previousMousePosition.x; // Calculate deltaX for touch
                deltaY = event.changedTouches[0].clientY - previousMousePosition.y; // Calculate deltaY for touch
            } else {
                deltaX = event.clientX - previousMousePosition.x; // Calculate deltaX for mouse
                deltaY = event.clientY - previousMousePosition.y; // Calculate deltaY for mouse
            }

            // Adjust planet rotation velocity based on drag
            selectedPlanet.userData.rotationVelocity.y += deltaX * 0.0005; // Adjust Y velocity
            selectedPlanet.userData.rotationVelocity.x += deltaY * 0.0005; // Adjust X velocity

            // Update previous mouse position
            if (event.changedTouches) {
                previousMousePosition.x = event.changedTouches[0].clientX;
                previousMousePosition.y = event.changedTouches[0].clientY;
            } else {
                previousMousePosition.x = event.clientX;
                previousMousePosition.y = event.clientY;
            }
        }

        // Function to handle mouse up event
        function onMouseUp() {
            isDragging = false; // Disable dragging
        }

        // Add event listeners for mouse and touch events
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseup', onMouseUp, false);
        document.addEventListener('touchstart', onMouseDown, false);
        document.addEventListener('touchmove', onMouseMove, false);
        document.addEventListener('touchend', onMouseUp, false);

        // Variable for time calculation
        var timeVar = Date.now() * 0.0001;

        // Animation loop
        function animate() {
            requestAnimationFrame(animate); // Request the next frame for animation

            // Check if not dragging
            if(isDragging == false){
                orbitingSpheres.forEach((planet) => {
                    // Time-based animation for planet movement
                    this.timeVar = this.timeVar + 0.001;
                    const time = this.timeVar;
                    const index = orbitingSpheres.indexOf(planet);
                    const angle = (2 * Math.PI / numberOfPlanets) * index + 0.1 * time;

                    // Update planet position based on orbit
                    planet.position.x = orbitRadiusX * Math.cos(angle);
                    planet.position.y = orbitRadiusZ * Math.sin(angle) * Math.sin(orbitTiltAngle);
                    planet.position.z = orbitRadiusZ * Math.sin(angle) * Math.cos(orbitTiltAngle);

                    // Calculate distance from camera to adjust scale
                    const distance = camera.position.distanceTo(planet.position);
                    const scale = Math.max(2, 2 - Math.abs(distance - camera.position.z) / 20);
                    planet.scale.set(scale, scale, scale);

                    // Apply rotation velocity and damping to the planet
                    planet.rotation.y += planet.userData.rotationVelocity.y;
                    planet.rotation.x += planet.userData.rotationVelocity.x;
                    planet.userData.rotationVelocity.x *= planet.userData.damping;
                    planet.userData.rotationVelocity.y *= planet.userData.damping;
                });
            }

            renderer.render(scene, camera); // Render the scene
        }

        animate(); // Start the animation loop

    </script>
</body>
</html>
