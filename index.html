<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simpless</title>
    <script src="https://threejs.org/build/three.min.js"></script>
</head>
<body>
    <script>
        // Scene, Camera, and Renderer
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(40, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer();
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        // Central Sphere - Sun
        const sunGeometry = new THREE.SphereGeometry(6, 32, 32);
        const sunTexture = new THREE.TextureLoader().load('logo.png');
        const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture });
        const sun = new THREE.Mesh(sunGeometry, sunMaterial);
        scene.add(sun);

        // Planets Variables
        const numberOfPlanets = 10;
        const orbitRadiusX = 30;
        const orbitRadiusZ = 15;
        const orbitTiltAngle = -0.2;
        const orbitingSpheres = [];

        // Creating Planets
        for (let i = 0; i < numberOfPlanets; i++) {
            const planetGeometry = new THREE.SphereGeometry(2, 100, 100);
            const planetTexture = new THREE.TextureLoader().load(i + '.png');
            const planetMaterial = new THREE.MeshBasicMaterial({ map: planetTexture });
            const planet = new THREE.Mesh(planetGeometry, planetMaterial);

            planet.position.x = orbitRadiusX * Math.cos((2 * Math.PI / numberOfPlanets) * i);
            planet.position.y = orbitRadiusZ * Math.sin((2 * Math.PI / numberOfPlanets) * i) * Math.sin(orbitTiltAngle);
            planet.position.z = orbitRadiusZ * Math.sin((2 * Math.PI / numberOfPlanets) * i) * Math.cos(orbitTiltAngle);

            planet.userData = { 
                rotationVelocity: { x: 0, y: 0 },
                damping: 0.95
            };

            scene.add(planet);
            orbitingSpheres.push(planet);
        }

        // Camera Position
        camera.position.set(50, 50, -50);
        camera.lookAt(scene.position);

        // Raycaster and Mouse Variables
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isDragging = false;
        let selectedPlanet = null;
        let previousMousePosition = { x: 0, y: 0 };

        function updateMousePosition(event) {
            mouse.x = ((event.clientX || event.touches[0].clientX) / window.innerWidth) * 2 - 1;
            mouse.y = -((event.clientY || event.touches[0].clientY) / window.innerHeight) * 2 + 1;
        }

        function onMouseDown(event) {
            updateMousePosition(event);
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(orbitingSpheres);

            if (intersects.length > 0) {
                isDragging = true;
                selectedPlanet = intersects[0].object;
                previousMousePosition.x = mouse.x;
                previousMousePosition.y = mouse.y;
            }
        }

        function onMouseMove(event) {
            if (!isDragging || !selectedPlanet) return;
            updateMousePosition(event);

            const deltaX = event.clientX - previousMousePosition.x;
            const deltaY = event.clientY - previousMousePosition.y;

            selectedPlanet.userData.rotationVelocity.y += deltaX * 0.0005;
            selectedPlanet.userData.rotationVelocity.x += deltaY * 0.0005;

            previousMousePosition.x = event.clientX;
            previousMousePosition.y = event.clientY;
        }

        function onMouseUp() {
            isDragging = false;
        }

        // Event Listeners
        document.addEventListener('mousedown', onMouseDown, false);
        document.addEventListener('mousemove', onMouseMove, false);
        document.addEventListener('mouseup', onMouseUp, false);
        document.addEventListener('touchstart', onMouseDown, false);
        document.addEventListener('touchmove', onMouseMove, false);
        document.addEventListener('touchend', onMouseUp, false);

        // Animation Loop
        function animate() {
            requestAnimationFrame(animate);

            orbitingSpheres.forEach((planet) => {
                const time = Date.now() * 0.001;
                const index = orbitingSpheres.indexOf(planet);
                const angle = (2 * Math.PI / numberOfPlanets) * index + 0.1 * time;

                planet.position.x = orbitRadiusX * Math.cos(angle);
                planet.position.y = orbitRadiusZ * Math.sin(angle) * Math.sin(orbitTiltAngle);
                planet.position.z = orbitRadiusZ * Math.sin(angle) * Math.cos(orbitTiltAngle);

                const distance = camera.position.distanceTo(planet.position);
                const scale = Math.max(2, 2 - Math.abs(distance - camera.position.z) / 20);
                planet.scale.set(scale, scale, scale);

                // Apply rotation velocity and damping
                planet.rotation.y += planet.userData.rotationVelocity.y;
                planet.rotation.x += planet.userData.rotationVelocity.x;

                planet.userData.rotationVelocity.x *= planet.userData.damping;
                planet.userData.rotationVelocity.y *= planet.userData.damping;
            });

            renderer.render(scene, camera);
        }

        animate();

    </script>
</body>
</html>
